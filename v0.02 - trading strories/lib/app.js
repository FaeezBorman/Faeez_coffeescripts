// Generated by CoffeeScript 1.6.1
(function() {
  var Config, Functions, indicator, sellTrade, story;

  sellTrade = (function() {

    function sellTrade(tn, p, v, tf, tp, sl, tpv, slv) {
      this.tn = tn;
      this.p = p;
      this.v = v;
      this.tf = tf;
      this.tp = tp;
      this.sl = sl;
      this.tpv = tpv;
      this.slv = slv;
    }

    sellTrade.prototype.current = function() {
      var c;
      c = {
        tn: this.tn,
        p: this.p,
        v: this.v,
        tf: this.tf,
        tp: this.tp,
        sl: this.sl,
        tpv: this.tpv,
        slv: this.slv
      };
      return c;
    };

    sellTrade.prototype.ctpsl = function(up, down) {
      this.up = up;
      this.down = down;
      this.tp = this.p - this.down;
      this.sl = this.p + this.up;
      this.tpv = (this.p * this.v) / this.tp;
      return this.slv = (this.p * this.v) / this.sl;
    };

    sellTrade.prototype.csl = function(cp, diff) {
      this.cp = cp;
      this.diff = diff;
      this.sl = this.cp + this.diff;
      return this.slv = (this.p * this.v) / this.sl;
    };

    sellTrade.prototype.ctp = function(cp, diff) {
      this.cp = cp;
      this.diff = diff;
      this.tp = this.cp * (100 - this.difF) / 100;
      return this.tpv = (this.p * this.v) / this.tpv;
    };

    sellTrade.prototype.log = function() {
      var d;
      return d = "trade number :" + this.tn + " at price " + this.p + " v: " + this.v + " tf: " + this.tf + " tp: " + this.tp + " sl: " + this.sl;
    };

    return sellTrade;

  })();

  indicator = (function() {

    function indicator(in_name, in_desc, in_act, in_price, in_low, in_ave, in_high, in_last) {
      this.in_name = in_name;
      this.in_desc = in_desc;
      this.in_act = in_act;
      this.in_price = in_price;
      this.in_low = in_low;
      this.in_ave = in_ave;
      this.in_high = in_high;
      this.in_last = in_last;
    }

    return indicator;

  })();

  story = (function() {

    function story(story_string, story_price, story_count, story_averageprice) {
      this.story_string = story_string;
      this.story_price = story_price;
      this.story_count = story_count;
      this.story_averageprice = story_averageprice;
    }

    story.prototype.run = function(story_price) {
      this.story_price = story_price;
      this.story_count = this.story_count + 1;
      return this.story_averageprice = (this.story_averageprice + this.storyprice) / 2;
    };

    return story;

  })();

  Functions = (function() {

    function Functions() {}

    Functions.diff = function(x, y) {
      return ((x - y) / ((x + y) / 2)) * 100;
    };

    Functions.ema = function(data, period) {
      var results;
      results = talib.EMA({
        inReal: data,
        startIdx: 0,
        endIdx: data.length - 1,
        optInTimePeriod: period
      });
      return _.last(results);
    };

    Functions.sar = function(high, low, accel, max) {
      var results;
      results = talib.SAR({
        high: high,
        low: low,
        startIdx: 0,
        endIdx: high.length - 1,
        optInAcceleration: accel,
        optInMaximum: max
      });
      return _.last(results);
    };

    Functions.sar_ext = function(high, low, start_value, offset_on_rev, accel_init_long, accel_long, accel_max_long, accel_init_short, accel_short, accel_max_short) {
      var results;
      results = talib.SAREXT({
        high: high,
        low: low,
        startIdx: 0,
        endIdx: high.length - 1,
        optInStartValue: start_value,
        optInOffsetOnReverse: offset_on_rev,
        optInAccelerationInitLong: accel_init_long,
        optInAccelerationLong: accel_long,
        optInAccelerationMaxLong: accel_max_long,
        optInAccelerationInitShort: accel_init_short,
        optInAccelerationShort: accel_short,
        optInAccelerationMaxShort: accel_max_short
      });
      return _.last(results);
    };

    Functions.aroon = function(high, low, period) {
      var result, results;
      results = talib.AROON({
        high: high,
        low: low,
        startIdx: 0,
        endIdx: high.length - 1,
        optInTimePeriod: period
      });
      result = {
        up: _.last(results.outAroonUp),
        down: _.last(results.outAroonDown)
      };
      return result;
    };

    Functions.macd = function(data, fast_period, slow_period, signal_period) {
      var result, results;
      results = talib.MACD({
        inReal: data,
        startIdx: 0,
        endIdx: data.length - 1,
        optInFastPeriod: fast_period,
        optInSlowPeriod: slow_period,
        optInSignalPeriod: signal_period
      });
      result = {
        macd: _.last(results.outMACD),
        signal: _.last(results.outMACDSignal),
        histogram: _.last(results.outMACDHist)
      };
      return result;
    };

    Functions.rsi = function(data, period) {
      var results;
      results = talib.RSI({
        inReal: data,
        startIdx: 0,
        endIdx: data.length - 1,
        optInTimePeriod: period
      });
      return _.last(results);
    };

    Functions.populate = function(target, ins, step) {
      var i, t, _i, _ref, _results;
      if (step == null) {
        step = 1;
      }
      _results = [];
      for (i = _i = 0, _ref = ins.close.length / step; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        t = {
          open: ins.open.slice(0, +i + 1 || 9e9),
          close: ins.close.slice(0, +i + 1 || 9e9),
          high: ins.high.slice(0, +i + 1 || 9e9),
          low: ins.low.slice(0, +i + 1 || 9e9)
        };
        _results.push(target.put(t));
      }
      return _results;
    };

    Functions.can_buy = function(ins, min_btc, fee_percent) {
      return portfolio.positions[ins.curr()].amount >= ((ins.price * min_btc) * (1 + fee_percent / 100));
    };

    Functions.can_sell = function(ins, min_btc) {
      return portfolio.positions[ins.asset()].amount >= min_btc;
    };

    Functions.buy = function(instrument, limit_percent, timeout) {
      return buy(instrument, null, instrument.price * (1 + limit_percent / 100), timeout);
    };

    Functions.sell = function(instrument, limit_percent, timeout) {
      return sell(instrument, null, instrument.price * (1 - limit_percent / 100), timeout);
    };

    return Functions;

  })();

  Config = (function() {

    function Config(long_open, long_close, short_open, short_close, sar_accel, sar_max, aroon_period, aroon_threshold, macd_fast_period, macd_slow_period, macd_signal_period, macd_short, macd_long, rsi_period, rsi_high, rsi_low) {
      this.long_open = long_open;
      this.long_close = long_close;
      this.short_open = short_open;
      this.short_close = short_close;
      this.sar_accel = sar_accel;
      this.sar_max = sar_max;
      this.aroon_period = aroon_period;
      this.aroon_threshold = aroon_threshold;
      this.macd_fast_period = macd_fast_period;
      this.macd_slow_period = macd_slow_period;
      this.macd_signal_period = macd_signal_period;
      this.macd_short = macd_short;
      this.macd_long = macd_long;
      this.rsi_period = rsi_period;
      this.rsi_high = rsi_high;
      this.rsi_low = rsi_low;
    }

    return Config;

  })();

  ({
    init: function(context) {
      context.pair = 'btc_usd';
      context.trend = false;
      context.sell_treshold = 0.25;
      context.init = false;
      context.stoploss = 0.0;
      context.close = 2;
      context.trade_mini = 0.0;
      context.tradeNo = 0.0;
      context.price = 0.0;
      context.vol = 0.0;
      context.takeProfit = 0.0;
      context.tf = 0.0;
      context.newhighmode = false;
      context.trade = [];
      context.lastshorter = 999999;
      context.enable_ha = false;
      context.last_sar = 999;
      context.config = new Config(0.1, 0.3, 0.3, 2.4, 0.025, 0.2, 10, 20, 14, 22, 9, 0, 1, 20, 52, 48);
      context.high = 800;
      context.low = 800;
      return context.last_high = 600;
    },
    handle: function(context, data) {
      var H, L, btc_have, fiat_have, hlmode, hlrange, i, ihigh, ilow, instrument, l, max, min, psar, sar, x, _i, _results;
      instrument = data[context.pair];
      fiat_have = portfolio.positions[instrument.curr()].amount;
      btc_have = portfolio.positions[instrument.asset()].amount;
      context.tf = 0;
      hlmode = new indicator("", "", false);
      hlrange = new indicator("", "", false);
      max = talib.MAX({
        inReal: instrument.high,
        startIdx: 0,
        endIdx: instrument.high.length - 13,
        optInTimePeriod: 12
      });
      min = talib.MIN({
        inReal: instrument.low,
        startIdx: 0,
        endIdx: instrument.low.length - 13,
        optInTimePeriod: 12
      });
      H = max[max.length - 1];
      L = min[min.length - 1];
      ihigh = instrument.high[instrument.high.length - 1];
      ilow = instrument.low[instrument.low.length - 1];
      if (ihigh >= H) {
        context.high = ihigh;
        hlmode = new indicator("HL", "new highs: price above last resistance", false);
      }
      if (context.last_high > context.high && ihigh >= H) {
        hlmode = new indicator("HL", "price is dropping from testing new highs", true);
      } else {
        context.last_high = context.high;
      }
      if (ilow <= L) {
        context.low = ilow;
        hlmode = new indicator("HL", "new lows: price below last resistance", false);
      }
      if (ihigh <= H && ilow >= L && ihigh <= context.high && ilow >= context.low) {
        hlmode = new indicator("HL", "in range: price between H and L", false);
      }
      if ((context.high - context.low) > 30) {
        hlrange = new indicator("HLRH", "big range", true, context.high - context.low);
      }
      if ((context.high - context.low) > 20) {
        hlrange = new indicator("HLRM", "medium range", true, context.high - context.low);
      }
      if ((context.high - context.low) < 20) {
        hlrange = new indicator("HLRL", "low range", false, context.high - context.low);
      }
      if (context.enable_ha) {
        sar = Functions.sar(context.ha.ins.high, context.ha.ins.low, 0.025, 0.2);
      } else {
        sar = Functions.sar(instrument.high, instrument.low, 0.025, 0.2);
        if (sar > instrument.price) {
          psar = new indicator("SAR", "sar indicating start of down trend", true);
        } else {
          psar = new indicator("SAR", "sar indicating up trend", false);
        }
        context.last_sar = sar;
      }
      plot({
        cH: context.high,
        cL: context.low,
        sar: sar,
        lasthigh: context.last_high
      });
      for (i in context.trade) {
        if (H > context.high) {
          context.trade[i].csl(context.high, 1);
        }
        if (H < context.high && instrument.price < H) {
          context.trade[i].csl(H, 1);
        }
      }
      for (i in context.trade) {
        l = context.trade[i].current();
        if (instrument.price <= l.tp) {
          debug("Sell: " + l.v + " @ " + l.p + " | Buy : " + (instrument.price.toFixed(2)));
          buy(instrument, l.tpv);
          context.trade.splice(i, 1);
        }
        if (instrument.price >= l.sl) {
          debug("!STOP! Sell: " + l.v + " @ " + l.p + " | Buy : " + (instrument.price.toFixed(2)));
          buy(instrument, l.slv);
          context.trade.splice(i, 1);
        }
      }
      if (hlmode.in_act && hlrange.in_act && psar.in_act) {
        debug("" + hlmode.in_desc + " and " + hlrange.in_desc + " and " + psar.in_desc);
        context.tf = 4;
      }
      if (context.tf > 0) {
        context.tradeNo = context.tradeNo + 1;
        context.vol = btc_have * (context.tf / 10);
        context.price = instrument.price;
        sell(instrument, context.vol);
        if (hlrange.in_price > 20) {
          _results = [];
          for (x = _i = 1; _i <= 3; x = ++_i) {
            _results.push(context.trade.push(new sellTrade(context.tradeNo, context.price, context.vol / 3, context.tf)));
          }
          return _results;
        }
      }
    }
  });

}).call(this);
